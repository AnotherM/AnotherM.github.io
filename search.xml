<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LearnPython(7)]]></title>
    <url>%2F2019%2F08%2F04%2FLearnPython-7%2F</url>
    <content type="text"><![CDATA[Python学习笔记7 2019/8/4，本章主要记录Python的OS库操作This Article Is Not Python Tutorial，极大部分包含了个人的主观意见，知识仅供参考，本文目前使用Python版本为3.7.3 路都是自己走出来的 OS库路径操作import os# 返回绝对路径print(os.path.abspath("D://Projects//PyCharm//LearnPython//L8//1_OS.py")) # 返回使用\分割的路径print(os.path.normpath("D://Projects//PyCharm//LearnPython//L8//1_OS.py")) # 程序和文件之间的相对路径print(os.path.relpath("D://Projects//PyCharm//LearnPython//L8//1_OS.py")) # 返回目录名称print(os.path.dirname("D://Projects//PyCharm//LearnPython//L8//1_OS.py")) # 返回路径最后的文件名print(os.path.basename("D://Projects//PyCharm//LearnPython//L8//1_OS.py")) # 组合字符串返回路径print(os.path.join("D://Projects", "//PyCharm//LearnPython//L8//1_OS.py"))# 判断路径存在 print(os.path.exists("D://Projects//PyCharm//LearnPython//L8//1_OS.py")) # 判断是文件print(os.path.isfile("D://Projects//PyCharm//LearnPython//L8//1_OS.py")) # 判断是目录print(os.path.isdir("D://Projects//PyCharm//LearnPython//L8//1_OS.py")) # 得到访问时间print(os.path.getatime("D://Projects//PyCharm//LearnPython//L8//1_OS.py")) # 得到修改时间print(os.path.getmtime("D://Projects//PyCharm//LearnPython//L8//1_OS.py")) # 得到创建时间print(os.path.getctime("D://Projects//PyCharm//LearnPython//L8//1_OS.py")) # 得到文件大小print(os.path.getsize("D://Projects//PyCharm//LearnPython//L8//1_OS.py")) 进程管理# 执行计算器os.system("C:\\Windows\\System32\\calc.exe")# 调用绘图os.system("C:\\Windows\\System32\\mspaint.exe D:\\Projects\\PyCharm\\LearnPython\\L7\\5_WordCloud.png") 环境参数print(os.getcwd()) # 返回程序当前路径print(os.getlogin()) # 获取当前系统用户名print(os.cpu_count()) # 获取CPU内核数量print(os.urandom(10)) # 获取10个字节长度的随机字符串，用于加密和解密运算 自动化安装脚本编写import oslibs = &#123;"numpy", "matplotlib", "pillow", "jieba", "wordcloud"&#125;try: for lib in libs: os.system("pip install " + lib) print("success")except: print("error")]]></content>
      <categories>
        <category>小世界</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LearnPython(6)]]></title>
    <url>%2F2019%2F07%2F25%2FLearnPython-6%2F</url>
    <content type="text"><![CDATA[Python学习笔记6 2019/7/25，本章主要记录Python文件操作This Article Is Not Python Tutorial，极大部分包含了个人的主观意见，知识仅供参考，本文目前使用Python版本为3.7.3 路都是自己走出来的 文件在Python中打开一个文件# 以文本模式打开text_file = open('1_File.txt', 'rt') print(text_file.readline())text_file.close()# 以二进制模式打开binary_file = open('1_File.txt', 'rb') print(binary_file.readline())binary_file.close() 文件打开模式# r代表只读模式，默认以只读模式打开，若文件不存在返回FileNotFoundErrorfile_r = open('1_File.txt', 'r') # w代表覆盖写入模式，若文件不存在则创建，存在则覆盖file_w = open('1_File.txt', 'w') # x代表创建写入模式，若文件不存在则创建，存在则返回FileExistsError file_x = open('1_File.txt', 'x') # a代表追加写入模式，若文件不存在则创建，存在则在文件最后追加内容file_a = open('1_File.txt', 'a') # b代表以二进制形式读取文件file_b = open('1_File.txt', 'b') # t代表以文本文件形式读取文件file_t = open('1_File.txt', 't') # +代表在原功能基础上增加读写功能file_plus = open('1_File.txt', 'a+') 文件读取模式# 全部内容按字读取file_read = open('1_File.txt')print(file_read.read()) file_read.close()file_readline = open('1_File.txt')# 读文件单行内容print(file_readline.readline()) file_readline.close()file_readlines = open('1_File.txt')# 读整个文件，将每行以元素形式存为列表print(file_readlines.readlines()) file_readlines.close() 文本遍历# 一次读取file_once = open('1_File.txt', 'r')print(file_once.read())file_once.close()# 逐步读取file_step = open('1_File.txt', 'r')read = file_step.read(1)while read != "": read = file_step.read(10) print(read)file_step.close()# 一次读入，分行处理file_line = open('1_File.txt', 'r')for line in file_line.readlines(): print(line)file_line.close()# 分行读入，逐次处理file_lines = open('1_File.txt', 'r')for line in file_lines: print(line)file_lines.close() 文件写入file_write = open('1_File_Output_1.txt', 'w+')list = ['Python', 'Learn', 'Note', 'By', 'Another.M']file_write.writelines(list)for line in file_write: print(line)file_write.close()file_write = open('1_File_Output_2.txt', 'w+')list = ['Python', 'Learn', 'Note', 'By', 'Another.M']file_write.writelines(list)# 将指针（光标）移动到0位置（开头）file_write.seek(0)for line in file_write: print(line)file_write.close()]]></content>
      <categories>
        <category>小世界</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LearnPython(5)]]></title>
    <url>%2F2019%2F07%2F17%2FLearnPython-5%2F</url>
    <content type="text"><![CDATA[Python学习笔记5 2019/7/17，本章主要记录Python集合、序列以及字典This Article Is Not Python Tutorial，极大部分包含了个人的主观意见，知识仅供参考，本文目前使用Python版本为3.7.3 路都是自己走出来的 集合集合类型# 集合是无序的# 使用&#123;&#125;建立集合A = &#123;'python', 123, ("python", 123), "Python", "python123", "Python123"&#125;print(A) # 使用set()建立集合B = set("python123") print(B)# 集合元素唯一C = &#123;"p", 123, "y", "python123", "python", 123, 123, 123&#125; print(C) 集合操作符print(B | C) # 并集，B和C所有元素 print(B - C) # 差集，在B不在C中的元素 print(B &amp; C) # 交集，B和C共有元素 print(B ^ C) # 补集，B和C非相同元素 print(B &lt; C) # 判断子集关系 print(B &gt; C) # 判断包含关系 集合处理方法# 返回A的复制D = A.copy()print(D) print(A) D = D - Aprint(D) print(A) # 返回A的元素个数print(len(A)) # 判断A中有C元素print(A in C) # 判断A中无C元素print(A not in C) # 将E转换为集合E = "python"print(E) print(set(E)) # 添加不包含在A中的元素A.add("python")A.add("anaconda")print(A) # 移除A中的元素，若不包含也不报错A.discard("anaconda")print(A) # 移除A中的元素，若不包含返回KeyError# A.remove("anaconda")A.remove("python")print(A) # 随即返回A中一个元素，更新A，若A为空则产生KeyErrorA.pop()print(A) # 移除A中所有元素A.clear()print(A) 序列 序列与集合不同，所有序列之间的元素都是有顺序的 序列通用操作sequences = ["python", 12345, ",./'", ",.s23/4s"]# 判断python是sequence的元素print("python" in sequences) # 判断python不是sequence的元素print("python" not in sequences)# 连接两个序列print(sequences + sequences)# 将序列复制3次print(sequences * 3)# 索引，返回第2个元素print(sequences[2]) # 切片，返回第包含第2-3元素的子序列print(sequences[1:3]) # 切片，返回包含2-4步长为2的元素的子序列print(sequences[1:4:2])# 切片，将序列反转print(sequences[::-1]) 列表类型# 使用[]或list()创建，元素之间用逗号分隔lists = ["cat", "dog", "fish", 123]print(lists) # 替换列表第4个元素为birdlists[3] = "bird" print(lists) # 将列表切片后，替换对应位置的元素子列表lists[0:2] = ["fish", "dog", 123] print(lists) # 删除列表中1-3个元素del lists[0:2] print(lists) # 在列表最后增加一个元素lists.append("application") print(lists) # 复制列表lists1 = lists.copy() print(lists1) # 清除列表元素lists1.clear() print(lists1)# 在列表第2个位置插入11223344lists.insert(1, 11223344) print(lists) # 取出（出栈）列表第2个位置的元素，返回值lists.pop(1)print(lists) # 删除列表的123这个元素lists.remove(123) print(lists) # 反转列表lists.reverse() print(lists) 元组类型 与列表不同，元组一旦创建就不可修改 # 使用()或tuple()创建，元素之间用逗号分隔# 元组的创建可以不使用小括号tuples = "cat", "dog", "fish", "bird"print(tuples) # 元组嵌套tuples = (tuples, tuples)print(tuples)# 将列表转换为元组，用于数据保护tuples1 = tuple(lists) print(tuples1)]]></content>
      <categories>
        <category>小世界</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LearnPython(4)]]></title>
    <url>%2F2019%2F06%2F27%2FLearnPython-4%2F</url>
    <content type="text"><![CDATA[Python学习笔记4 2019/6/19，本章主要记录Python函数以及递归This Article Is Not Python Tutorial，极大部分包含了个人的主观意见，知识仅供参考，本文目前使用Python版本为3.7.3 路都是自己走出来的 函数s = 0 # 全局变量a = 2000# 定义函数def func(b): global a # 使用关键字，将全局变量引入局部，用于更改赋值，并保证全局变量值不变 a = 1 # 给全局变量赋值 return aprint(a, func(a)) # 调用函数，传递参数，使用global关键字的a的为1，全局变量a的值依然为2000， 递归# 使用递归将字符反转后输出def rvs(n): if n == "": return n else: return rvs(n[1:]) + n[0]# 斐波那契数列def fibonacci(n): if n == 1 or n == 2: return 1 else: return fibonacci(n - 1) + fibonacci(n - 2)# 汉诺塔count = 0def hanoi(n, src, dst, mid): global count if n == 1: print("&#123;&#125;:&#123;&#125;-&gt;&#123;&#125;".format(1, src, dst)) count += 1 else: hanoi(n - 1, src, mid, dst) print("&#123;&#125;:&#123;&#125;-&gt;&#123;&#125;".format(n, src, dst)) count += 1 hanoi(n - 1, mid, dst, src)print(rvs("TEST TEST EST ST T"))print(fibonacci(23))print(hanoi(3, "A", "C", "B"))]]></content>
      <categories>
        <category>小世界</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LearnPython(3)]]></title>
    <url>%2F2019%2F06%2F21%2FLearnPython-3%2F</url>
    <content type="text"><![CDATA[Python学习笔记3 2019/6/21，本章主要记录Python分支结构、循环结构This Article Is Not Python Tutorial，极大部分包含了个人的主观意见，知识仅供参考，本文目前使用Python版本为3.7.3 路都是自己走出来的 分支结构单分支结构guess = eval(input("猜数字（1-9）："))if guess == 9: print("正确") 二分支结构if guess == 8: print("正确")else: print("错误") print('&#123;&#125;'.format('t' if guess == 8 else 'f')) # 紧凑形式 多分支结构score = eval(input("输分数（0-100）："))grade = ""if score &gt;= 60: grade = "D"elif score &gt;= 70: grade = "C"elif score &gt;= 80: grade = "B"elif score &gt;= 90: grade = "A"print("输入成绩属于级别&#123;&#125;".format(grade)) 条件判断和组合# or关键字，逻辑或if guess &gt; 7 or guess &lt; 9: print("or")# and关键字，逻辑与elif guess &gt; 1 and guess &gt; 6: print("and")# not关键字，逻辑非elif not False: print("not") 异常处理try: num = eval(input("请输入一个整数")) print(num ** 2)except NameError: print("输入不是整数") 循环结构计数遍历循环# 5次循环 for (int i=0;i&lt;5;i++)for i in range(5): print(i)# 从2-7步长为2 for (int i=2;i&lt;7;)&#123;i+=2;&#125;for i in range(2, 7, 2): print(i) 字符串遍历循环for c in "Python": print(c, end=",") 列表遍历循环for line in [123, 'Python', 456, "Another.M"]: print(line, end=",") 文件遍历循环file = open("3_Loop.txt")for line in file: print(line) 无限循环a = 3while a &gt; 0: print(a) 循环控制string = "Python"for c in string: if c == "t": continue # 跳出单次循环 print(c, end="")else: # 未使用break，继续执行 print("正常退出")for c in string: if c == "t": break # 跳出整个循环 print(c, end="")else: # 使用break，不执行 print("正常退出")while string != "": for c in string: if c == "t": break # 仅跳出最内层循环 print(c, end="") string = string[:-1] Random库import random# 梅森旋转算法生成随机数print(random.random()) # random种子，默认当前系统时间# random.seed(10) # 种子固定，随机数则不变print(random.random()) # 生成[10,100]之间的整数print(random.randint(10, 100)) # 生成[10,100]之间以10为步长的整数print(random.randrange(10, 100, 10)) # 生成k比特长的整数print(random.getrandbits(8))print(random.getrandbits(16))print(random.getrandbits(32))# 生成[a,b]之间的小数print(random.uniform(10, 100)) # 从序列seq中选择一个元素s = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]print(random.choice(s)) # 将seq中元素随机排序，返回打乱后的序列random.shuffle(s)print(s) 圆周率计算from random import randomfrom time import perf_counter"""近似计算"""# 公式1/pow(16,k)*(4/(8*k+1)-2/(8*k+4)-1/(8*k+5)-1/(8*k+6))pi = 0N = 100for k in range(N): pi += 1 / pow(16, k) * (4 / (8 * k + 1) - 2 / (8 * k + 4) - 1 / (8 * k + 5) - 1 / (8 * k + 6))print("&#123;&#125;".format(pi))"""蒙特卡罗（蒙眼戳飞镖）"""DARTS = 1000 * 1000hits = 0.0start = perf_counter()for i in range(1, DARTS + 1): x, y = random(), random() dist = pow(x ** 2 + y ** 2, 0.5) if dist &lt;= 1.0: hits = hits + 1pi = 4 * (hits / DARTS)print("&#123;&#125;".format(pi))print("&#123;&#125;".format(perf_counter() - start))]]></content>
      <categories>
        <category>小世界</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LearnPython(2)]]></title>
    <url>%2F2019%2F06%2F19%2FLearnPython-2%2F</url>
    <content type="text"><![CDATA[Python学习笔记2 忙了三个月毕设，2019/6/19，继续编写，本章主要记录Python数字类型及操作、字符串类型及操作、Time库的使用This Article Is Not Python Tutorial，极大部分包含了个人的主观意见，知识仅供参考，本文目前使用Python版本为3.7.3 路都是自己走出来的 数字类型操作Python整数类型 十进制 decimal_1 = 123decimal_2 = 29decimal_3 = -127 二进制，以0b或0B开头 binary_1 = 0b010binary_2 = -0B101 八进制 以0o或者0O开头 octal_1 = 0o123octal_2 = -0O345 十六进制 以0x或者0X开头 hexadecimal_1 = 0x9ahexadecimal_2 = -0X89 浮点数 取值范围数量级约-10^308至10^308，精度数量级10^-16 浮点数之间的运算存在不确定尾数，不是bug，计算机组成原理知识 计算机取0.1只能截取53位二进制表示小数部分，约为10^-16，去无限接近0.1print(0.1 + 0.3) # 0.4print(0.1 + 0.2) # 0.30000000000000004print(0.1 + 0.2 == 0.3) # False 复数 复数定义：x^2=-1，定义j=√(-1)，a+bj被称为复数，其中，a是实部，b是虚部 只有Python提供了复数 z = 1.23e-4 + 5.6e+89jprint(z.real) # 实部0.000123print(z.imag) # 虚部5.6e+89 运算符 Python中除了常规的+ - * / %还有//和，//为整数除，结果为整数商，为幂运算，幂为小数则开方运算 同时运算符也可用作赋值操作符，即x+=y x-=y x**=yprint(10 / 3) # 3.3333333333333335print(10 // 3) # 3print(10 ** 5) # 100000print(10 ** 0.5) # 3.1622776601683795 类型之间的关系为逐渐“拓展”或“变宽”：整数→浮点数→复数 数字函数import mathprint(abs(-10)) # 绝对值 10print(divmod(20, 7)) # 求商余 (x//y,x%y) (2, 6)print(pow(3, pow(3, 3), 10000)) # 求幂余 (x**y)%z z即10000可省略 print(pow(3, 27, 10000)) 4587print(round(math.pi, 3)) # 四舍五入，3为保留3位小数，默认为0可省略print(max(1, 7, 2, 8, 3, 9)) # 最大值 9print(min(3, 1, 6, 4, 9, 7)) # 最小值 1print(int(math.pi)) # 舍弃小数变整数 3print(float(3)) # 将整数变为浮点数 3.0print(complex(5)) # 将某个数字变为复数并增加虚部 (5+0j) 字符串类型操作字符串 字符串由一对单引号或一对双引号表示 string_1 = 'str'string_2 = "string2" 三单引号或三双引号表示多行字符串 string_3 = """multilinestring""" Python具备多种字符串表示方法是为了更好的处理字符串 string_4 = """This ""is"" a Multi LineAnd'Multi Quotation Marks'string """ 字符串是字符的有序序列，使用[]可以对其中的字符进行索引、切片 print(string_1[1]) # tprint(string_1[-1]) # [-1]代表倒数第一位字符串 rprint(string_2[6]) # 2print(string_3[1:3]) # ulprint(string_4[0:-12]) # [0:-12]代表从字符串第一位开始，输出至倒数第12位字符串# this ""is""# a multi line# and# 'multi quotation marprint(string_4[0:-3:2]) # [0:-3:2]代表从字符串第一位开始，输出至倒数第3位字符串，步长（跳过字符数）为1# ti "s"# ut iead'ut utto ak'srn 转义字符 print("双引号\"") # 双引号 双引号"print("回退1格\b") # 回退 回退1print("换\n行") # 换行（光标移动到下行行首）# 换# 行print("回\r车") # 回车（光标移动到本行行首）车 字符串操作 print(string_1 + string_2) # 拼接字符串 strstring2print(string_1 * 3) # 复制3次字符串 strstrstrprint(string_1 in string_2) # 判断string_1是否为string_2的子串 True 字符串函数 print(len(string_4)) # 输出字符串长度 62print(str(1.234), str([1, 2, 3])) # 转换任意类型数据为字符串 1.234 [1, 2, 3]print(hex(420), oct(420)) # 转换整数位十六进制或八进制的小写字符串 0x1a4 0o644print(chr(10004)) # 输出Unicode编码字符 ✔print(ord("✔")) # 返回Unicode编码值 10004 字符串处理方法 print(string_4.upper()) # 所有字母大写# THIS ""IS""# A MULTI LINE# AND# 'MULTI QUOTATION MARKS'# STRINGprint(string_4.lower()) # 所有字母小写# this ""is""# a multi line# and# 'multi quotation marks'# stringprint(string_4.split(sep=" ")) # 使用空格分隔字符串存入列表# ['This', '""is""', '\na', 'Multi', "Line\nAnd\n'Multi", 'Quotation', "Marks'\nstring\n", '']print(string_4.count("a")) # 返回字符a在string_4中出现的次数 3print(string_3.replace("i", "abc")) # 替换所有i字母为abc# multabc# labcne# strabcngprint(string_2.center(20, "-")) # 使字符串根据所需宽度居中，填充- ------string2-------print("string_abc".strip(string_1)) # 从string_abc字符串中去除string_1的内容 ing_abcprint(",".join(string_1)) # 在逗号中加入string_1的内容用于分割 s,t,r 字符串格式化 print("&#123;&#125;年&#123;&#125;月&#123;&#125;日，作者&#123;&#125;".format(2019, 6, 20, "anotherm4")) # &#123;&#125;填充参数，2019年6月20日，作者anotherm4print("&#123;2&#125;日，作者&#123;3&#125;，&#123;1&#125;月&#123;0&#125;年".format(2019, 6, 20, "anotherm4")) # 顺序控制，20日，作者anotherm4，6月2019年print("&#123;:-&gt;20,.2f&#125;".format(1234567.12345)) # --------1,234,567.12# &#123;:&lt;填充-&gt;&lt;右对齐&gt;&lt;宽度20&gt;&lt;使用,作为千位分隔符&gt;&lt;使用.定义浮点数精度&gt;&lt;数据类型为浮点数f&gt;&#125;# &lt;左对齐 &gt;右对齐 ^居中对齐# b,c,d,o,x,X整数类型 e,E,f,%浮点数类型 Time库使用Python时间处理import timeprint(time.time()) # 返回时间戳 1561020541.161563print(time.ctime()) # 返回时间字符串 Thu Jun 20 16:49:01 2019print(time.gmtime()) # 获取计算机可处理的时间格式# time.struct_time(tm_year=2019,tm_mon=6,tm_mday=20,tm_hour=8,tm_min=49,tm_sec=1,tm_wday=3,tm_yday=171,tm_isdst=0)print(time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime())) # 格式化时间# %Y年 %m月 %B月份名称 %b月份名称缩写 %d日 %A星期 %a星期缩写 %H24小时制 %h12小时制 %p上午下午 %M分钟 %S秒start = time.perf_counter()time.sleep(0.2)end = time.perf_counter()print(end - start) # 0.2045585 文本进度条实现import timescale = 10start = time.perf_counter()for i in range(scale + 1): a = '*' * i b = '.' * (scale - i) c = (i / scale) * 100 dur = time.perf_counter() - start # print("\r&#123;:3&#125;%".format(i), end="") # 单行简易打印 # print("&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]".format(c, a, b)) # 多行打印 print("\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s".format(c, a, b, dur), end="") time.sleep(1)]]></content>
      <categories>
        <category>小世界</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客界面效果小更新（二）]]></title>
    <url>%2F2019%2F04%2F14%2FBlogUpdateB%2F</url>
    <content type="text"><![CDATA[严格地说，这篇文章，应该属于想到什么写什么，鉴于有点偷懒，基本就是全贴图算了 Next主题更新7.0.1：Theme-Next Git分支合并以及merge upstream： Git Syncing a fork: Syncing a fork Git给fork配置upstream: Configuring a remote for a fork 加入Gitment: Gitment is a comment system based on GitHub Issues 更新avatar：]]></content>
      <categories>
        <category>Notice</category>
      </categories>
      <tags>
        <tag>Something</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WSL服务启动脚本]]></title>
    <url>%2F2019%2F04%2F14%2FWSLServiceScript%2F</url>
    <content type="text"><![CDATA[摘要对于Linux来说，部署环境比Windows便利很多，比如安装mysql、nginx等只需如apt install mysql &amp; apt install nginx一条命令，但是个人又离不开Windows 对于WSL来说，很多人为了便利或者说偷懒，做了用PowerShell做了开机脚本和启动项，但是估计也有一部分人不算很愿意为了几个Linux服务，拖慢Windows的开机速度（虽然不一定有关系，除非你电脑真的很渣很渣😂） 所以呢，既然WSL是Linux（Windows是最好的Linux发行版！！！） 所以用shell脚本，启动服务也是可以的吧 注：本文灵感来源于：Linux手动启动、停止多个服务用的shell脚本 不多说，贴出自己修改后的脚本，用于启动WSL中的mysql + ssh + rabbitmq-server + redis-server 其中SERVICE等变量可以修改为自己所需要的服务，若有多个服务，需在start()、stop()、status()中写入变量 #!/bin/bashSERVICE_1=mysqlSERVICE_2=sshSERVICE_3=rabbitmq-serverSERVICE_4=redis-serverfunction help()&#123; echo "Usage: $0&#123;start|stop|status|help&#125;"&#125;function check_service_if_is_running()&#123; SERVICE=$1 service $SERVICE status &gt; /dev/null REVAL=$? if [[ $REVAL -eq 0 ]]; then return 0 else return 1 fi&#125;function start_service_if_is_stoped()&#123; SERVICE=$1 service $SERVICE start &gt; /dev/null check_service_if_is_running $SERVICE REVAL=$? if [[ $REVAL -eq 0 ]]; then echo $SERVICE is running... else echo $SERVICE is not running, error code is $REVAL. exit 1 fi&#125;function stop_service_if_is_running()&#123; SERVICE=$1 service $SERVICE stop &gt; /dev/null check_service_if_is_running $SERVICE REVAL=$? if [[ $REVAL -eq 1 ]]; then echo $SERVICE is stoped... fi&#125;function status_service()&#123; SERVICE=$1 check_service_if_is_running $SERVICE REVAL=$? if [[ $REVAL -eq 0 ]]; then echo $SERVICE is running... else echo $SERVICE is not running, error code is $REVAL. exit 1 fi&#125;function start()&#123; start_service_if_is_stoped $SERVICE_1 start_service_if_is_stoped $SERVICE_2 start_service_if_is_stoped $SERVICE_3 start_service_if_is_stoped $SERVICE_4&#125;function stop()&#123; stop_service_if_is_running $SERVICE_4 stop_service_if_is_running $SERVICE_3 stop_service_if_is_running $SERVICE_2 stop_service_if_is_running $SERVICE_1&#125;function status()&#123; status_service $SERVICE_1 status_service $SERVICE_2 status_service $SERVICE_3 status_service $SERVICE_4&#125;case "$1" in start) start ;; stop) stop ;; status) status ;; *) help exit 1 ;;esac 最后，贴上运行效果]]></content>
      <categories>
        <category>小世界</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桌面美化]]></title>
    <url>%2F2019%2F04%2F12%2FDesktopEffect%2F</url>
    <content type="text"><![CDATA[软件Wallpaper Engine TranslucentTB Rainmeter 腾讯桌面整理 主题Rainmeter－SimpleNova WallpaperEngine－「ー」/「しおん」 效果Your browser does not support the video tag.]]></content>
      <categories>
        <category>小世界</category>
      </categories>
      <tags>
        <tag>Where Am I</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LearnPython(1)]]></title>
    <url>%2F2019%2F02%2F24%2FLearnPython-1%2F</url>
    <content type="text"><![CDATA[Python学习笔记 坑了很长时间，2019/2/24，推翻重构，本章主要记录Python学习概览This Article Is Not Python Tutorial，极大部分包含了个人的主观意见，知识仅供参考，本文目前使用Python版本为3.7.2 本笔记所有内容均来源于北京理工大学嵩天的《Python程序语言设计》 路都是自己走出来的 Python格式框架 严格缩进：有道是：让Python程序员最疯狂的是什么？那就是给他的代码随便加个空格 Python没有花括号和分号，所以对格式就是严格要求，正是因为格式，Python的代码显得干净整洁 单一程序内，缩进严格要求为N个空格或者N个Tab键，N为正整数并且单一程序内N的值不能改变（若缩进为4个空格，则单一程序内缩进需要全部使用4个空格） Python有两种注释：使用'''```作为多行注释## Python关键字（2019/6/19更新）&gt;使用```import keyword```与```keyword.kwlist```查看保留字关键字|说明---|---|---```False```|为假判定，首字母大写固定```None```|特殊空值，不为0，不等于&apos; &apos;```True```|为真判定，首字母大写固定```and```|逻辑与运算，```a and b```类似于```a &amp;&amp; b ```import tensorflow as tf``````assert```|断言，用于检查单个条件，为假抛出AssertionError```async```|与```def```结合使用，包装函数为异步函数```async def function(): pass def function(): pass```中使用```await function()```，暂停协程的执行```break```|跳出整个循环```class```|创建类，包含```def```，面向对象编程思想```continue```|跳出单个循环```def```|创建函数，类似于void，包含```return list[0]```为删除list中第一个元素```elif```|```if()&#123;&#125; else if()&#123;&#125;```中的```else if else&#123;&#125;```中的```else```，可用于异常捕获，在不出现异常时候执行```else``中的代码```except```|```try&#123;&#125; catch(Exception e)&#123;&#125;```中的```catch```，在出现异常时侯执行```except```中的代码```finally```|```try&#123;&#125; catch(Exception e)&#123;&#125; finally&#123;&#125;```中的```finally```，不管是否出现异常都执行```finally```中的代码```for```|循环，结合```in```使用， ```for a in range(30): datetime import datetime``````global```|在```def```中使用，用于调用全局变量并且在不改变原值的情况下赋值```if```|```if()&#123;&#125; else&#123;&#125;```中的```if datetime``````in```|与```for```结合使用```is```|判断两个变量是否引用同一对象，```a=1 b=1 print(a is b) #True x:x+1```类似于```int x```nonlocal```|将函数内局部变量非全局变量的局部变量，用于单个方法或函数内部私有化变量调用```not```|逻辑非运算，```if not (a and b)```类似于```if(!a &amp;&amp; b) or b```类似于``` a || b ``````pass```|占位关键字，填充报错信息，```try: xxx except: pass ```return```|与```def```结合使用，用于退出函数、返回表达式、参数值```try```|```try: xxx except: pass```中的```try ```with```|可结合```as```使用，用于上下文支持，```with open(r&apos;fileName&apos;) as f: pass ## Python字符操作* Python字符拥有编号：**正向递增序号**：从左到右从0开始递增，**反向递减序号：**从右到左从-1开始递减* 使用```&lt;Str&gt;[M]```对字符串进行索引，如```&quot;Str[-1]&quot;```为字符串从右到左数第一个字符* 使用```&lt;Str&gt;[M:N]```对字符串进行切片，如```Str[1:3]```就是从左数第2个字符和第3个字符，但不到第4个字符（从左往右数从0开始），使用```Str[0:-2]```则为从左到右除了倒数第二个字符以外全部保留## Python列表* 列表使用```[]```表示，如```[&apos;A&apos;,&apos;a&apos;]```为一个包含两个元素的列表，使用```Str in [&apos;A&apos;,&apos;a&apos;]```来判断Str中是否有匹配元素```A```或```a Python判断 Python判断中的## Python输入输出* Python使用```input()```函数进行输入，如```Str = input(&quot;请输入&quot;) Python使用* ```eval()```函数，用于去掉表达式外侧引号并执行余下的函数，如```eval(&quot;1&quot;)```输出结果为```1```而不是```&quot;1&quot;```，而```eval(&quot;1+2&quot;)```输出结果为```3```，若```eval(&apos;&quot;1+2&quot;&apos;)```则输出结果为```&apos;1+2&apos;```，其中```eval(&quot;&apos;1+2&apos;&quot;)```输出结果也为```&apos;1+2&apos;```，因为在Python中，单引号与双引号只是为了避免转义字符，即无需使用```\```进行转义，同理，若```eval(&apos;print(&quot;hello&quot;)&apos;)```输出为```hello```，也就是执行了```print()```函数# Turtle库的使用## 使用Turtle画彩虹（2019/6/20更新）```pythonimport turtle as tdef init(x, y, z, speed): t.setup(x, y) t.pensize(z) t.speed(speed)def start(start, end): t.penup() t.setx(start) t.sety(end) t.pendown()def draw(color, position, radius, extend): t.pendown() t.left(position) t.color(color) t.circle(radius, extend) t.penup()init(800, 800, 20, 10)start(100, 0)draw(&apos;red&apos;, 90, 100, 180)start(120, 0)draw(&apos;orange&apos;, 180, 120, 180)start(140, 0)draw(&apos;yellow&apos;, 180, 140, 180)start(160, 0)draw(&apos;green&apos;, 180, 160, 180)start(180, 0)draw(&apos;cyan&apos;, 180, 180, 180)start(200, 0)draw(&apos;blue&apos;, 180, 200, 180)start(220, 0)draw(&apos;purple&apos;, 180, 220, 180)t.done()]]></content>
      <categories>
        <category>小世界</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WSL + Redis与redis-py的使用]]></title>
    <url>%2F2019%2F01%2F29%2FWSL-RedisAndRedis-py%2F</url>
    <content type="text"><![CDATA[WSL + Redis与redis-py的使用本文章适用于有一定Linux基础的朋友，如果对Linux不熟悉的话，慢慢来，先学Linux命令- 事情梗概最近无事，整理电脑时候看见一个redis-5.0.2.tar.gz静静的躺在某个角落 想起本来要再Windows上试验一下Redis 解压缩之后，看到了installserver. sh，嗯，这货看来是Linux版本的 去官网看了一下，只有一个Download按钮，去查了查，作者觉得Windows太麻烦所以不打算开发 找了找，发现了Microsoft Archive，竟然有Windows版本的Redis，看一下Release，嗯，Lastest Release是3.0.504,刚接触，啥也不知道，点了下载，然后一看发布的日期1 Jul 2016，玩个鬼头啊 整双系统吧，Rufus刻录完了Fedora，进BIOS关Secure Boot，安装时发现没分区，分区完了再装发现Fedora这货***哔***把EFI给我装硬盘没挂载到固态上，格式化分区重装，您所使用的分区无法挂载EFI（掀桌） 折腾了两个小时，放弃了，想起了WSL，删除了msys2（为啥删我也不知道） 啰嗦了这么多，转向正题 启用WSL Win + S - 启用或关闭Windows功能 - 适用于Linux的Windows子系统 - Microsoft Store - 搜索Linux - 在Windows上运行Linux Ubuntu、openSUSE、SUSE、Debian、Kali Linux五种看个人喜好，本人选择的是Ubuntu 安装Redis 装好之后开始菜单打开Ubuntu，等待Install好后，设置username、password，修改源（可选，如果忍受得了官方源200kb/s的速度的话），本人用的是中科大源 换源之后执行sudo apt update更新源，执行sudo apt upgrade更新一下软件包，然后使用sudo apt install redis-server安装redis 启用Redis 安装好之后sudo vim /etc/redis/redis.conf,为安全起见使用vim的/bind搜索到bind 127.0.0.1使用#注释，/requirepass搜索到密码并设置，守护进程daemonize设置为yes（未实验对于WSL来说是否有作用） 执行redis-server看到以下结果说明Redis安装成功，使用sudo service redis-server start启动Redis服务 使用Redis 执行redis-cli，终端显示127.0.0.1:6379，端口号可以在redis.conf内更改，输入ping，提示(error) NOAUTH Authentication required.，使用auth &lt;你刚刚在redis.conf中设置的密码&gt;，显示OK，输入ping，显示PONG 环境搭建好了，现在该测试redis-py了，本人使用的是Anaconda环境，在Anaconda Prompt中输入conda install redis-py，等待安装完成，输入python进入Python环境，依次输入import redis、r = redis.Redis(host=&#39;127.0.0.1&#39;,port=6379,db=0,password=&#39;你设置的密码&#39;)、r.set(&#39;test&#39;,&#39;redis-py test&#39;)、print(r.get(&#39;test&#39;))查看结果，或将这四句写入python的可执行脚本 注意事项： 由于WSL的特殊性，此方法每次需启动WSL输入sudo service redis-server start使用 可编写WSL的启动脚本，加入Windows的启动项，在此作为延伸不做实现 sudo systemctl enable redis-server对于WSL无用，每次重启后Windows任务管理器内的WSL相关进程依然会消失]]></content>
      <categories>
        <category>小世界</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian-Keyring]]></title>
    <url>%2F2018%2F12%2F06%2FDebian-Keyring%2F</url>
    <content type="text"><![CDATA[这次的标题是 🤦‍登陆SSH，使用apt update更新一下软件包，然后提示NO_PUBKEY XXXXXXXXXXXXXXXX随即各种搜索，提示都是一致的提示使用gpg --keyserver keyring.debian.com --recv-keys 输入之后，再次使用apt update报错依旧 然后查了一下还需要gpg --armor --export XXXXXXXX | apt-key add - 使用之后，报错依旧 然后找到了一个网页上说删除debian-archive-keyring这个包然后使用apt --fix-broken install就好了 系统提示Please input the phrase: Yes, do as I say!，犹豫了一下……Ctrl + C……找了一会儿依然修不好 apt remove debian-archive-keyringYes, do as I say! 然后…… 我就这个表情： 😐 看了一下dpkg --help，有输出 随即 wget http://ftp.debian.org/debian/pool/main/a/apt/apt_1.4.8_amd64.deb`dpkg -i apt_1.4.8_amd64.deb 提示 dpkg: dependency problems prevent configuration of apt:apt depends on debian-archive-keyring; however:Package debian-archive-keyring is not installed.` wget http://ftp.debian.org/debian/pool/main/d/debian-archive-keyring/debian-archive-keyring_2017.5_all.debdpkg -i debian-archive-keyring_2017.5_all.debdpkg -i dpkg -i apt_1.4.8_amd64.debapt update 依然报错NO_PUBKEY XXXXXXXXXXXXXXXX 然后想起来彻底删除一下apt purge debian-archive-keyring提示 while removing debian-archive-keyring, directory &gt;’/etc/apt/trusted.gpg.d’ not empty so not removed执行 rm -r /etc/apt/trusted.gpg.ddpkg -i debian-archive-keyring_2017.5_all.debdpkg -i dpkg -i apt_1.4.8_amd64.debapt update 🙃 希望帮到有用的人]]></content>
      <categories>
        <category>学习中遇到的坑</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Archieved]]></title>
    <url>%2F2018%2F12%2F01%2FArchieved%2F</url>
    <content type="text"><![CDATA[2016/11/21-2017/04/07 期间学习总结已经归档不可访问此博客内容已经接近全面更新]]></content>
      <categories>
        <category>Notice</category>
      </categories>
      <tags>
        <tag>Something</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask初探]]></title>
    <url>%2F2018%2F11%2F19%2FFlaskTest%2F</url>
    <content type="text"><![CDATA[Flask初探昨天花时间研究了一下Spring与SpringBoot相关的知识，然后过了一天，整个人就是这种感觉: 你脑袋有毛病我不想和你玩 今天看了看Flask 然后就有了这篇文章的标题—-Flask初探 关于这篇文章的内容呢，就是教你用9行写出一个网站 所以： 要求： First: 你会用电脑 Second: 你会装Python并且会添加环境变量 Third: 你会用cmd 如果这些你都不具备的话那还是洗洗睡吧 接下来是正文 在以上条件都具备之后，打开cmd，执行pip install flask 新建一个后缀名为.py的文件 打开.py这个文件 写入 from flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return 'fxckUJava'if __name__ == '__main__': app.run() 用cmd找到这个文件（cd命令） 使用python xxx .py(xxx为你的文件名)，出现下图后，打开浏览器，访问127.0.0.1:5000 如果看不到任何东西或者页面没反应的话，恩，从头看看哪里搞错了吧 附：Flask官网 Python官网]]></content>
      <categories>
        <category>小世界</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客界面效果小更新]]></title>
    <url>%2F2017%2F04%2F04%2FBlogUpdateA%2F</url>
    <content type="text"><![CDATA[因多说评论系统关闭，所以整了整网页，准备取消多说服务，顺便翻了翻我现在正在使用的NexT主题，发现主题作者更新了，尤其意外的发现添加了canvas nest这个动态背景效果，于是连带Hexo一起更新了一下 目前使用的背景为NexT的three_wave，具体可在作者主题文档找到 至于评论系统，反正也没人评论，所以干脆不弄了 2018.12.01更新：多说已经关闭，而且canvas_line这个特效好炫酷，至于评论系统，嗯，洗洗睡吧😂,然后NexT主题已经交由NexT组织更新，目前版本6.0]]></content>
      <categories>
        <category>Notice</category>
      </categories>
      <tags>
        <tag>Something</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我所用过的各版本Linux的浅谈]]></title>
    <url>%2F2016%2F07%2F27%2FLinuxExperience%2F</url>
    <content type="text"><![CDATA[以下所写仅为个人观点，真实感受请自己体验，如有雷同，那就让它雷同吧2018.12.01更新:拥有VPS管理经验大概2年左右了，期间主要使用CentOS 6，最近更换了Debian 9，所以更新了一下大部分内容 文中部分文字、简介等来源于维基百科-Linux发行版列表 先列出我所用过的Linux，按使用先后排序 Ubuntu Ubuntu Kylin Kali Linux Deepin elementary OS CentOS Debian Arch Linux 添加Fedora，Manjaro的部分简述，删除和修改了一些无用的描述，把 “★(\u2605)” 更换成为了 “⭐(\u2B50)” ，算是为了网页添加了一丝色彩，虽然不知道能不能被识别 以下为各版本的个人体会，推荐度基于整体综合考虑Ubuntu 简介：基于Debian，由Canonical公司赞助 使用感受：直观感觉就是上手非常容易，自带LibreOffice，自带Firefox，安装软件可以通过软件中心，或者直接apt-get install &quot;package name&quot;(16.04版本已经精简为apt)，而且界面相对于其他的Linux来说很漂亮，适用于外观党，而且懒得折腾界面与不会折腾的新手，目前在实体机上依然使用中Ubuntu变化挺大，Unity全面变为GNOME，18.04LTS 获得10年支持，虽然没详细关注过，但仍不失一个好的发行版 推荐度：⭐⭐⭐⭐ 没啥可说的，依然是四星，用于开发还行，做服务器我可能不会选择 Ubuntu Kylin 简介：基于Ubuntu的Linux发行版，以中国大陆用户为主，中文名为“优麒麟” 主要开发者为 Ubuntu Kylin 社区、国防科学技术大学（NUDT）与 Canonical公司 使用感受：说白了就是Ubuntu的中国定制版，本地化比较好一些，自带软件相对于Ubuntu有一些不同，其余与Ubuntu基本没有太大区别，但是由于个人有一些精神洁癖，所以这个版本并未使用超过2小时 推荐度：未知，不做评价很久很久没有用过了，据说自己搞了个新的UI，精神洁癖倒是没有了（毕竟开源万岁😂） Kali Linux 简介：基于Debian的Linux发行版， 设计用于数字鉴识和渗透测试。由Offensive Security Ltd维护和资助。 使用感受：在Android 2.3时期就听说过使用手机虚拟机跑BackTrack可以破解别人的无线网，虽然我试过没成功，但是后来BackTrack发展成了这个Kali Linux，我用虚拟机和实体机分别尝试过，但是因为是用于渗透和破解的系统，过于高端而当时我的技术不达标所以放弃了，总的来说就是如果你想往渗透破解反编译这方面发展的话，可以考虑使用 推荐度：⭐⭐⭐依旧三星吧，毕竟没有深入了解过渗透，只玩过Steam上面的Hacknet，不过肯定是安全人员的首选了，顺便说一句：违法的事情不要做 Deepin 简介：基于Ubuntu，0.x版基于Debian。经历过多个桌面环境的变更（IceWM,xfce,LXDE,GNOME)，从Linux Deepin 12.12开始使用自主研发的DDE，15.2已重新基于Debian并切DDE已经升级为3.0 使用感受：当初无意间注意到的，版本还是14，貌似就是这个时候火起来的，尝试实体机安装了一下，安装过程竟然简单到点三次下一步就可以了，而且自带一些深度软件，也就是其发行公司自行开发的软件，短暂用了一段时间，优点是比Ubuntu还容易上手，由于14基于Ubuntu，所以用起来还算不错，新版本15据说是因为换了Debian变得不算太稳定，并且由于个人已经将Ubuntu作为常用系统，所以新版本只在虚拟机上看了看，总的来说，是个不错的选择，并且这个系统前景很宽阔，可以作为常用 推荐度：⭐⭐⭐⭐联合创始人离职，红芯套壳，虽然这两个事情根本联系不起来，但是谁实打实干事情谁心里清楚 elementary OS 简介：基于Ubuntu的Linux发行版。它使用一个自己开发的基于GNOME的名为Pantheon的桌面环境，从为Ubuntu设计的一套主题和应用程序发展而来 使用感受：当初没事的时候找到的，但个人使用没超过15分钟，简单来说就是一套改了主题的Ubuntu，而且改得还挺不错，据一些网络评论说是可以提供类似于Mac OS X的体验，但是我没觉得，不过对于外观党，是个不错的选择 推荐度：⭐⭐不关注了，但是在DistroWatch上面排名也挺靠前的了，现在应该需要改成⭐⭐⭐⭐ CentOS 简介：Linux发行版之一，它是来自于Red Hat Enterprise Linux依照开放源代码规定发布的源代码所编译而成，属于Red Hat系，使用RPM作为软件包 使用感受：一共安装了4次，使用的版本为Everything ISO，也就是全功能版，第一次安装由于是体验，所以就选择了最大化安装（虚拟机），用了大概一个小时，体验还算不错，因为是区别于Debian系列的Red Hat系，所以使用起来很新颖，于是想要实体机尝试一下，刚开始安装的时候选了最小化安装，结果就得到了一句话：“这特么是什么鬼”。后来查了查，最小化安装没有GUI，也就是没有图形界面，然后选了KDE作为桌面环境安装了一次，但是KDE桌面稳定个人觉得有些难用，所以又选择了GNOME来安装，用了大概一个小时，还是用回了Ubuntu，对于CentOS个人是特别满意的，因为这系统虽然自带OpenJDK，但是个人相对来说还是喜欢用OracleJDK，而OracleJDK分两种安装格式，一种是RPM，一种是压缩包，简而言之，Red Hat系对于开发支持方面比Ubuntu高的多一些，实际使用差别不大 推荐度：⭐⭐⭐⭐VPS上用了一年半多，只能说除了稳，没啥缺点了，不过想吐槽的是CentOS的软件更新速度，用过Manjaro之后就会觉得CentOS，太稳了都不敢轻易更新的🤦‍ Debian 简介：由GPL和其他自由软件许可协议授权的自由软件组成的操作系统，由Debian项目（Debian Project）组织维护，Software in the Public Interest提供支持并持有商标作为保护机构 使用感受：要说感受比较深的应该就是这个了，毕竟Ubuntu和Kali Linux都是基于Debian的，提供xfce,LXDE,GNOME,KDE四种桌面环境，同CentOS,还是GNOME相对来说好折腾一些，但实际使用上手不如Ubuntu与Deepin容易，功能相对于CentOS比较弱，因为Debian的精神就是坚守Unix和自由软件，所以对于用户的选择很多，也就是玩Linux熟练到一定程度之后就可以尝试一下使用Debian，不管别人对我怎么看，对于我来说，这个系统就是个随便改，改得面目全非都行，反正是拿来玩的系统，用它来做开发，还是因人而异了吃我开源邪教！！！ 推荐度：⭐⭐⭐⭐⭐ Arch Linux 简介：基于KISS原则（Keep It Simple, Stupid 的首字母缩略字），朝向轻量（lightweight）以及简单（simple）的Linux发行版 使用感受：刚开始使用的时候我是拒绝的，因为UltraISO刻录的U盘启动盘在EFI下根本没法启动，别的Linux发行版却一点儿问题都没有，后来用了一个软件直接把Arch Linux刻到了硬盘里启动后，等了半天发现怎么没界面？后来才反应过来，这货特么的没有GUI，没有GUI，没有GUI，只有一个命令行，当时我就陷入了深思，后来看了看Arch Linux的Wiki，果断放弃了，因为我还没到达光靠命令行或终端就能解决一切问题的地步。Arch入门深似海，从此其他Linux是路人 推荐度：⭐⭐ Fedora 简介：长话短说-Redhat试验田 使用感受：dnf包管理器可比yum爽多了，至于包更新速度嘛，反正不会滚滚挂就是了 推荐度：⭐⭐⭐⭐ Manjaro 简介：Arch Linux我帮你攒好了，你就放心用 使用感受：用了Arch就能把别的Linux当路人了你还要我Manjaro说啥？ 推荐度：没法形容，不喜欢Linux的人自然不会喜欢 以上的一些，纯属个人经验，具体使用哪个版本，还要你们自己自行尝试，还是那句话：因人而异，不过总的来说，我推荐三个：Deepin适合日常娱乐，Ubuntu适合入手练习Linux，CentOS适合开发Debian、CentOS&gt;&gt;服务器，Fedora、Manjaor，Ubuntu&gt;&gt;桌面用户，Arch Linux？？？不存在的！！！ 顺便说个使用难度排序：Deepin &lt; Ubuntu = Ubuntu Kylin = elementary OS &lt; CentOS ≈ Debian &lt; Kali Linux &lt; Arch Linux ~]]></content>
      <categories>
        <category>小世界</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown常用语法测试]]></title>
    <url>%2F2016%2F04%2F14%2FMarkdownTest%2F</url>
    <content type="text"><![CDATA[图片测试 This is a test 一级标题测试This is a test 二级标题测试This is a test 三级标题测试This is a test 四级标题测试This is a test 五级标题测试This is a test 六级标题测试 单击进入我的GitHub 链接测试 public class test&#123; public void main(String []args)&#123; System.out.println("Test"); &#125;&#125; //代码块测试 public class test1{public void main(String[]args){System.out.println(&quot;Test&quot;);}}代码测试 This is a test 引用测试 多级列表测试 Test1 Test2 Test3 普通列表测试 Test1 Test2 Test3 Test 斜体测试 Test 粗体测试 Test 删除线测试 表格测试| 1 | 2 | 3 || - | - | - || 1 | 1 | 1 || 2 | 2 | 2 || 3 | 3 | 3 | 分割线测试]]></content>
      <categories>
        <category>小世界</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
